/**
 * Social account risk detector aggregates multiple signal families
 * to approximate the probability an account is automated or malicious.
 * Each analyzer focuses on a single signal cluster and returns both
 * a normalized score (0-100) and human-readable evidence.
 */

const SIGNAL_WEIGHTS = {
  profile: 0.18,
  content: 0.15,
  behavior: 0.17,
  network: 0.20,
  multimedia: 0.08,
  identity: 0.07,
  device: 0.05,
  reputation: 0.05,
  threatIntel: 0.05,
};

const clampScore = (value) => Math.max(0, Math.min(100, Number.isFinite(value) ? value : 0));

const percentage = (numerator, denominator) => {
  if (!denominator) return 0;
  return (numerator / denominator) * 100;
};

const stringSimilarity = (a = '', b = '') => {
  const shorter = a.length > b.length ? b : a;
  const longer = a.length > b.length ? a : b;
  if (!longer.length) return 1;
  let matches = 0;
  for (let i = 0; i < shorter.length; i++) {
    if (shorter[i] === longer[i]) matches += 1;
  }
  return matches / longer.length;
};

const shannonEntropy = (value = '') => {
  if (!value) return 0;
  const freq = {};
  for (const char of value) {
    freq[char] = (freq[char] || 0) + 1;
  }
  const len = value.length;
  return Object.values(freq).reduce((acc, count) => {
    const p = count / len;
    return acc - p * Math.log2(p);
  }, 0);
};

const evaluateProfileMetadata = (profile = {}) => {
  const { accountAgeDays = 0, hasDefaultAvatar = false, username = '', displayName = '', bio = '', urlPresent = false } = profile;
  let riskScore = 0;
  const evidence = [];

  if (accountAgeDays < 3) {
    riskScore += 35;
    evidence.push('Account younger than 3 days');
  } else if (accountAgeDays < 30) {
    riskScore += 15;
    evidence.push('Account younger than 30 days');
  }

  if (hasDefaultAvatar) {
    riskScore += 15;
    evidence.push('Default avatar detected');
  }

  const entropy = shannonEntropy(username);
  if (entropy > 4.2 && username.length > 10) {
    riskScore += 12;
    evidence.push('Username entropy suggests autogenerated handle');
  }

  const similarity = stringSimilarity(username.toLowerCase(), displayName.toLowerCase());
  if (similarity < 0.4 && displayName) {
    riskScore += 8;
    evidence.push('Display name and handle mismatch');
  }

  if (bio.length === 0) {
    riskScore += 10;
    evidence.push('Bio missing');
  } else if (bio.length < 20) {
    riskScore += 5;
    evidence.push('Bio unusually short');
  }

  if (urlPresent) {
    riskScore += 5;
    evidence.push('External URL in profile');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateContentSignals = (content = {}) => {
  const {
    posts = [],
    duplicateTextRatio = 0,
    avgPostLength = 0,
    maliciousLinkRatio = 0,
    languageDiversityScore = 0,
  } = content;

  const totalPosts = posts.length;
  let riskScore = 0;
  const evidence = [];

  if (duplicateTextRatio > 0.6) {
    riskScore += 25;
    evidence.push('High duplicate content');
  }

  if (avgPostLength < 40 && totalPosts > 0) {
    riskScore += 10;
    evidence.push('Posts are overly short');
  }

  if (maliciousLinkRatio > 0.2) {
    riskScore += 30;
    evidence.push('Links flagged as malicious');
  } else if (maliciousLinkRatio > 0.05) {
    riskScore += 15;
    evidence.push('Suspicious link patterns');
  }

  if (languageDiversityScore < 0.2 && totalPosts > 10) {
    riskScore += 10;
    evidence.push('Single language mimicry pattern');
  }

  const cadenceStdDev = content.postingCadenceStdDev ?? 0;
  if (cadenceStdDev < 1 && totalPosts > 5) {
    riskScore += 10;
    evidence.push('Highly regular posting cadence');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateBehaviorSignals = (behavior = {}) => {
  const {
    postsPerDay = 0,
    activeHoursMismatched = false,
    burstSessions = 0,
    automationIndicators = [],
    engagementSkewScore = 0,
  } = behavior;

  let riskScore = 0;
  const evidence = [];

  if (postsPerDay > 50) {
    riskScore += 30;
    evidence.push('Extreme posting frequency');
  } else if (postsPerDay > 20) {
    riskScore += 20;
    evidence.push('High posting frequency');
  }

  if (activeHoursMismatched) {
    riskScore += 10;
    evidence.push('Timezone mismatch vs profile origin');
  }

  if (burstSessions > 5) {
    riskScore += 15;
    evidence.push('Multiple burst activity sessions');
  }

  if ((automationIndicators || []).length > 0) {
    riskScore += 15;
    evidence.push('Automation patterns detected');
  }

  if (engagementSkewScore > 0.5) {
    riskScore += 10;
    evidence.push('Engagement concentrated on few targets');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateNetworkSignals = (network = {}) => {
  const {
    followers = 0,
    following = 0,
    clustersWithKnownBots = false,
    graphAnomalyScore = 0,
    reciprocityRatio = 0,
  } = network;

  let riskScore = 0;
  const evidence = [];

  if (followers === 0 && following > 100) {
    riskScore += 25;
    evidence.push('Zero followers but aggressive following');
  }

  if (followers > 0 && following > 0) {
    const ratio = followers / following;
    if (ratio < 0.1) {
      riskScore += 15;
      evidence.push('Suspicious follower/following ratio');
    }
  }

  if (clustersWithKnownBots) {
    riskScore += 30;
    evidence.push('Connected to known bot clusters');
  }

  if (graphAnomalyScore > 0.7) {
    riskScore += 20;
    evidence.push('Graph anomaly score high');
  }

  if (reciprocityRatio < 0.1 && following > 50) {
    riskScore += 10;
    evidence.push('Low reciprocity ratio');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateMultimediaSignals = (media = {}) => {
  const {
    reverseImageHit = false,
    exifMismatch = false,
    deepfakeConfidence = 0,
    mediaReusedCount = 0,
  } = media;

  let riskScore = 0;
  const evidence = [];

  if (reverseImageHit) {
    riskScore += 20;
    evidence.push('Profile image found elsewhere');
  }

  if (exifMismatch) {
    riskScore += 10;
    evidence.push('Metadata mismatch');
  }

  if (deepfakeConfidence > 0.7) {
    riskScore += 25;
    evidence.push('Profile media flagged as synthetic');
  }

  if (mediaReusedCount > 3) {
    riskScore += 10;
    evidence.push('Profile media reused across accounts');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateIdentitySignals = (identity = {}) => {
  const {
    phoneVerified = false,
    emailVerified = false,
    twoFactorEnabled = false,
    govIdVerified = false,
    paymentVerified = false,
  } = identity;

  let riskScore = 50; // Start with medium risk and subtract for verifications
  const evidence = [];

  if (phoneVerified) {
    riskScore -= 15;
    evidence.push('Phone verified');
  }

  if (emailVerified) {
    riskScore -= 5;
    evidence.push('Email verified');
  }

  if (twoFactorEnabled) {
    riskScore -= 10;
    evidence.push('2FA enabled');
  }

  if (govIdVerified) {
    riskScore -= 20;
    evidence.push('Government ID verified');
  }

  if (paymentVerified) {
    riskScore -= 10;
    evidence.push('Payment method verified');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateDeviceSignals = (device = {}) => {
  const {
    ipReputationScore = 0,
    vpnOrProxy = false,
    deviceFingerprintCount = 0,
    geoConsistencyScore = 1,
  } = device;

  let riskScore = 0;
  const evidence = [];

  if (ipReputationScore > 0.7) {
    riskScore += 20;
    evidence.push('Bad IP reputation');
  }

  if (vpnOrProxy) {
    riskScore += 15;
    evidence.push('Proxy or VPN usage');
  }

  if (deviceFingerprintCount > 5) {
    riskScore += 10;
    evidence.push('Multiple devices cycling');
  }

  if (geoConsistencyScore < 0.3) {
    riskScore += 10;
    evidence.push('Inconsistent geo metadata');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateReputationSignals = (reputation = {}) => {
  const {
    userReports = 0,
    confirmedAbuseCases = 0,
    manualReviewFlags = 0,
    enforcementHistory = 0,
  } = reputation;

  let riskScore = 0;
  const evidence = [];

  if (userReports > 5) {
    riskScore += 20;
    evidence.push('Multiple user reports');
  } else if (userReports > 0) {
    riskScore += 10;
    evidence.push('Some user reports');
  }

  if (confirmedAbuseCases > 0) {
    riskScore += 30;
    evidence.push('Historical abuse confirmed');
  }

  if (manualReviewFlags > 0) {
    riskScore += 15;
    evidence.push('Pending manual review outcomes');
  }

  if (enforcementHistory > 0) {
    riskScore += 15;
    evidence.push('Prior enforcement actions');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateThreatIntelSignals = (intel = {}) => {
  const {
    matchedFraudList = false,
    leakedCredentialMatch = false,
    maliciousDomainMatch = false,
  } = intel;

  let riskScore = 0;
  const evidence = [];

  if (matchedFraudList) {
    riskScore += 40;
    evidence.push('Matches external fraud watch list');
  }

  if (leakedCredentialMatch) {
    riskScore += 20;
    evidence.push('Credential appears in leak data');
  }

  if (maliciousDomainMatch) {
    riskScore += 20;
    evidence.push('Linked domain on threat intel list');
  }

  return { score: clampScore(riskScore), evidence };
};

/**
 * Analyze an account using all signal families
 * @param {object} payload - Raw signal payload from client or pipeline
 * @returns {object} Risk verdict with explanations
 */
export const analyzeSocialAccount = (payload = {}) => {
  const breakdown = {
    profile: evaluateProfileMetadata(payload.profileMetadata),
    content: evaluateContentSignals(payload.contentFeatures),
    behavior: evaluateBehaviorSignals(payload.behaviorPatterns),
    network: evaluateNetworkSignals(payload.networkSignals),
    multimedia: evaluateMultimediaSignals(payload.multimediaSignals),
    identity: evaluateIdentitySignals(payload.identitySignals),
    device: evaluateDeviceSignals(payload.deviceMetadata),
    reputation: evaluateReputationSignals(payload.reportSignals),
    threatIntel: evaluateThreatIntelSignals(payload.externalIntel),
  };

  const weightedScore = Object.entries(breakdown).reduce((acc, [key, result]) => {
    const weight = SIGNAL_WEIGHTS[key] ?? 0;
    return acc + result.score * weight;
  }, 0);

  const riskScore = Math.round(clampScore(weightedScore));
  const riskLevel = riskScore >= 75 ? 'CRITICAL' : riskScore >= 55 ? 'HIGH' : riskScore >= 35 ? 'MEDIUM' : 'LOW';

  const reasons = Object.values(breakdown)
    .flatMap((result) => result.evidence)
    .filter(Boolean);

  const prioritizedReasons = reasons.slice(0, 6);

  const recommendedAction =
    riskLevel === 'CRITICAL'
      ? 'Auto-lock account and escalate to fraud response'
      : riskLevel === 'HIGH'
        ? 'Throttle reach and queue for manual review'
        : riskLevel === 'MEDIUM'
          ? 'Introduce friction (captcha, 2FA challenge)'
          : 'Monitor silently';

  return {
    riskScore,
    riskLevel,
    recommendedAction,
    breakdown,
    reasons: prioritizedReasons,
    metadata: {
      evaluatedAt: new Date().toISOString(),
      missingSignals: Object.keys(breakdown).filter((key) => !payload?.[signalKeyToPayloadField(key)]),
      signalWeights: SIGNAL_WEIGHTS,
      confidence: calculateConfidence(payload),
    },
  };
};

const signalKeyToPayloadField = (key) => {
  switch (key) {
    case 'profile':
      return 'profileMetadata';
    case 'content':
      return 'contentFeatures';
    case 'behavior':
      return 'behaviorPatterns';
    case 'network':
      return 'networkSignals';
    case 'multimedia':
      return 'multimediaSignals';
    case 'identity':
      return 'identitySignals';
    case 'device':
      return 'deviceMetadata';
    case 'reputation':
      return 'reportSignals';
    case 'threatIntel':
      return 'externalIntel';
    default:
      return undefined;
  }
};

const calculateConfidence = (payload = {}) => {
  const populatedSignals = [
    'profileMetadata',
    'contentFeatures',
    'behaviorPatterns',
    'networkSignals',
    'multimediaSignals',
    'identitySignals',
    'deviceMetadata',
    'reportSignals',
    'externalIntel',
  ].filter((key) => Boolean(payload[key]));

  return Number((populatedSignals.length / 9).toFixed(2));
};

export default {
  analyzeSocialAccount,
};



