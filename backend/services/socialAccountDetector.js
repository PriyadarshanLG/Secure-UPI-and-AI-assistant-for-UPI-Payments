/**
 * Social account risk detector aggregates multiple signal families
 * to approximate the probability an account is automated or malicious.
 * Each analyzer focuses on a single signal cluster and returns both
 * a normalized score (0-100) and human-readable evidence.
 */

import logger from '../utils/logger.js';

const SIGNAL_WEIGHTS = {
  profile: 0.18,
  content: 0.15,
  behavior: 0.17,
  network: 0.20,
  multimedia: 0.08,
  identity: 0.07,
  device: 0.05,
  reputation: 0.05,
  threatIntel: 0.05,
};

const clampScore = (value) => Math.max(0, Math.min(100, Number.isFinite(value) ? value : 0));

const percentage = (numerator, denominator) => {
  if (!denominator) return 0;
  return (numerator / denominator) * 100;
};

const stringSimilarity = (a = '', b = '') => {
  const shorter = a.length > b.length ? b : a;
  const longer = a.length > b.length ? a : b;
  if (!longer.length) return 1;
  let matches = 0;
  for (let i = 0; i < shorter.length; i++) {
    if (shorter[i] === longer[i]) matches += 1;
  }
  return matches / longer.length;
};

const shannonEntropy = (value = '') => {
  if (!value) return 0;
  const freq = {};
  for (const char of value) {
    freq[char] = (freq[char] || 0) + 1;
  }
  const len = value.length;
  return Object.values(freq).reduce((acc, count) => {
    const p = count / len;
    return acc - p * Math.log2(p);
  }, 0);
};

const evaluateProfileMetadata = (profile = {}) => {
  const { accountAgeDays = 0, hasDefaultAvatar = false, username = '', displayName = '', bio = '', urlPresent = false } = profile;
  let riskScore = 0;
  const evidence = [];

  if (accountAgeDays < 3) {
    riskScore += 35;
    evidence.push('Account younger than 3 days');
  } else if (accountAgeDays < 30) {
    riskScore += 15;
    evidence.push('Account younger than 30 days');
  }

  if (hasDefaultAvatar) {
    riskScore += 15;
    evidence.push('Default avatar detected');
  }

  const entropy = shannonEntropy(username);
  if (entropy > 4.2 && username.length > 10) {
    riskScore += 12;
    evidence.push('Username entropy suggests autogenerated handle');
  }

  const similarity = stringSimilarity(username.toLowerCase(), displayName.toLowerCase());
  if (similarity < 0.4 && displayName) {
    riskScore += 8;
    evidence.push('Display name and handle mismatch');
  }

  if (bio.length === 0) {
    riskScore += 10;
    evidence.push('Bio missing');
  } else if (bio.length < 20) {
    riskScore += 5;
    evidence.push('Bio unusually short');
  }

  if (urlPresent) {
    riskScore += 5;
    evidence.push('External URL in profile');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateContentSignals = (content = {}) => {
  const {
    posts = [],
    duplicateTextRatio = 0,
    avgPostLength = 0,
    maliciousLinkRatio = 0,
    languageDiversityScore = 0,
  } = content;

  const totalPosts = posts.length;
  let riskScore = 0;
  const evidence = [];

  if (duplicateTextRatio > 0.6) {
    riskScore += 25;
    evidence.push('High duplicate content');
  }

  if (avgPostLength < 40 && totalPosts > 0) {
    riskScore += 10;
    evidence.push('Posts are overly short');
  }

  if (maliciousLinkRatio > 0.2) {
    riskScore += 30;
    evidence.push('Links flagged as malicious');
  } else if (maliciousLinkRatio > 0.05) {
    riskScore += 15;
    evidence.push('Suspicious link patterns');
  }

  if (languageDiversityScore < 0.2 && totalPosts > 10) {
    riskScore += 10;
    evidence.push('Single language mimicry pattern');
  }

  const cadenceStdDev = content.postingCadenceStdDev ?? 0;
  if (cadenceStdDev < 1 && totalPosts > 5) {
    riskScore += 10;
    evidence.push('Highly regular posting cadence');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateBehaviorSignals = (behavior = {}) => {
  const {
    postsPerDay = 0,
    activeHoursMismatched = false,
    burstSessions = 0,
    automationIndicators = [],
    engagementSkewScore = 0,
  } = behavior;

  let riskScore = 0;
  const evidence = [];

  if (postsPerDay > 50) {
    riskScore += 30;
    evidence.push('Extreme posting frequency');
  } else if (postsPerDay > 20) {
    riskScore += 20;
    evidence.push('High posting frequency');
  }

  if (activeHoursMismatched) {
    riskScore += 10;
    evidence.push('Timezone mismatch vs profile origin');
  }

  if (burstSessions > 5) {
    riskScore += 15;
    evidence.push('Multiple burst activity sessions');
  }

  if ((automationIndicators || []).length > 0) {
    riskScore += 15;
    evidence.push('Automation patterns detected');
  }

  if (engagementSkewScore > 0.5) {
    riskScore += 10;
    evidence.push('Engagement concentrated on few targets');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateNetworkSignals = (network = {}) => {
  const {
    followers = 0,
    following = 0,
    clustersWithKnownBots = false,
    graphAnomalyScore = 0,
    reciprocityRatio = 0,
  } = network;

  let riskScore = 0;
  const evidence = [];

  if (followers === 0 && following > 100) {
    riskScore += 25;
    evidence.push('Zero followers but aggressive following');
  }

  if (followers > 0 && following > 0) {
    const ratio = followers / following;
    if (ratio < 0.1) {
      riskScore += 15;
      evidence.push('Suspicious follower/following ratio');
    }
  }

  if (clustersWithKnownBots) {
    riskScore += 30;
    evidence.push('Connected to known bot clusters');
  }

  if (graphAnomalyScore > 0.7) {
    riskScore += 20;
    evidence.push('Graph anomaly score high');
  }

  if (reciprocityRatio < 0.1 && following > 50) {
    riskScore += 10;
    evidence.push('Low reciprocity ratio');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateMultimediaSignals = (media = {}) => {
  const {
    reverseImageHit = false,
    exifMismatch = false,
    deepfakeConfidence = 0,
    mediaReusedCount = 0,
  } = media;

  let riskScore = 0;
  const evidence = [];

  if (reverseImageHit) {
    riskScore += 20;
    evidence.push('Profile image found elsewhere');
  }

  if (exifMismatch) {
    riskScore += 10;
    evidence.push('Metadata mismatch');
  }

  if (deepfakeConfidence > 0.7) {
    riskScore += 25;
    evidence.push('Profile media flagged as synthetic');
  }

  if (mediaReusedCount > 3) {
    riskScore += 10;
    evidence.push('Profile media reused across accounts');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateIdentitySignals = (identity = {}) => {
  const {
    phoneVerified = false,
    emailVerified = false,
    twoFactorEnabled = false,
    govIdVerified = false,
    paymentVerified = false,
  } = identity;

  let riskScore = 50; // Start with medium risk and subtract for verifications
  const evidence = [];

  if (phoneVerified) {
    riskScore -= 15;
    evidence.push('Phone verified');
  }

  if (emailVerified) {
    riskScore -= 5;
    evidence.push('Email verified');
  }

  if (twoFactorEnabled) {
    riskScore -= 10;
    evidence.push('2FA enabled');
  }

  if (govIdVerified) {
    riskScore -= 20;
    evidence.push('Government ID verified');
  }

  if (paymentVerified) {
    riskScore -= 10;
    evidence.push('Payment method verified');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateDeviceSignals = (device = {}) => {
  const {
    ipReputationScore = 0,
    vpnOrProxy = false,
    deviceFingerprintCount = 0,
    geoConsistencyScore = 1,
  } = device;

  let riskScore = 0;
  const evidence = [];

  if (ipReputationScore > 0.7) {
    riskScore += 20;
    evidence.push('Bad IP reputation');
  }

  if (vpnOrProxy) {
    riskScore += 15;
    evidence.push('Proxy or VPN usage');
  }

  if (deviceFingerprintCount > 5) {
    riskScore += 10;
    evidence.push('Multiple devices cycling');
  }

  if (geoConsistencyScore < 0.3) {
    riskScore += 10;
    evidence.push('Inconsistent geo metadata');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateReputationSignals = (reputation = {}) => {
  const {
    userReports = 0,
    confirmedAbuseCases = 0,
    manualReviewFlags = 0,
    enforcementHistory = 0,
  } = reputation;

  let riskScore = 0;
  const evidence = [];

  if (userReports > 5) {
    riskScore += 20;
    evidence.push('Multiple user reports');
  } else if (userReports > 0) {
    riskScore += 10;
    evidence.push('Some user reports');
  }

  if (confirmedAbuseCases > 0) {
    riskScore += 30;
    evidence.push('Historical abuse confirmed');
  }

  if (manualReviewFlags > 0) {
    riskScore += 15;
    evidence.push('Pending manual review outcomes');
  }

  if (enforcementHistory > 0) {
    riskScore += 15;
    evidence.push('Prior enforcement actions');
  }

  return { score: clampScore(riskScore), evidence };
};

const evaluateThreatIntelSignals = (intel = {}) => {
  const {
    matchedFraudList = false,
    leakedCredentialMatch = false,
    maliciousDomainMatch = false,
  } = intel;

  let riskScore = 0;
  const evidence = [];

  if (matchedFraudList) {
    riskScore += 40;
    evidence.push('Matches external fraud watch list');
  }

  if (leakedCredentialMatch) {
    riskScore += 20;
    evidence.push('Credential appears in leak data');
  }

  if (maliciousDomainMatch) {
    riskScore += 20;
    evidence.push('Linked domain on threat intel list');
  }

  return { score: clampScore(riskScore), evidence };
};

/**
 * Analyze an account using all signal families
 * @param {object} payload - Raw signal payload from client or pipeline
 * @returns {object} Risk verdict with explanations
 */
export const analyzeSocialAccount = (payload = {}) => {
  const breakdown = {
    profile: evaluateProfileMetadata(payload.profileMetadata),
    content: evaluateContentSignals(payload.contentFeatures),
    behavior: evaluateBehaviorSignals(payload.behaviorPatterns),
    network: evaluateNetworkSignals(payload.networkSignals),
    multimedia: evaluateMultimediaSignals(payload.multimediaSignals),
    identity: evaluateIdentitySignals(payload.identitySignals),
    device: evaluateDeviceSignals(payload.deviceMetadata),
    reputation: evaluateReputationSignals(payload.reportSignals),
    threatIntel: evaluateThreatIntelSignals(payload.externalIntel),
  };

  const weightedScore = Object.entries(breakdown).reduce((acc, [key, result]) => {
    const weight = SIGNAL_WEIGHTS[key] ?? 0;
    return acc + result.score * weight;
  }, 0);

  const riskScore = Math.round(clampScore(weightedScore));
  const riskLevel = riskScore >= 75 ? 'CRITICAL' : riskScore >= 55 ? 'HIGH' : riskScore >= 35 ? 'MEDIUM' : 'LOW';

  // Check followers and following from network signals
  const networkSignals = payload.networkSignals || {};
  const followers = networkSignals.followers || 0;
  const following = networkSignals.following || 0;

  // Convert to numbers to ensure proper comparison
  const followersNum = Number(followers) || 0;
  const followingNum = Number(following) || 0;
  
  // Check profile metadata for profile photo
  const profileMetadata = payload.profileMetadata || {};
  const hasDefaultAvatar = profileMetadata.hasDefaultAvatar || false;
  
  // Log the values for debugging
  logger.info('Verdict calculation (FAKE DETECTION LOGIC):', {
    followers: followersNum,
    following: followingNum,
    hasDefaultAvatar: hasDefaultAvatar,
  });

  // FAKE DETECTION LOGIC (ONLY checks followers and following, NOT posts):
  // - If no profile photo (hasDefaultAvatar = true) → FAKE
  // - If followers < 20 → FAKE
  // - If following < 20 → FAKE
  // - Otherwise → REAL
  // NOTE: Posts count is NOT used in fake detection
  let isFake = false;
  let fakeReason = '';
  
  if (hasDefaultAvatar) {
    // No profile photo → FAKE
    isFake = true;
    fakeReason = 'No profile photo detected';
    logger.warn('Account marked FAKE: No profile photo', { 
      hasDefaultAvatar: hasDefaultAvatar 
    });
  } else if (followersNum < 20) {
    // Followers less than 20 → FAKE
    isFake = true;
    fakeReason = `Followers less than 20 (${followersNum} detected)`;
    logger.warn('Account marked FAKE: Followers < 20', { 
      followers: followersNum 
    });
  } else if (followingNum < 20) {
    // Following less than 20 → FAKE
    isFake = true;
    fakeReason = `Following less than 20 (${followingNum} detected)`;
    logger.warn('Account marked FAKE: Following < 20', { 
      following: followingNum 
    });
  } else {
    // All checks passed → REAL (posts count is ignored)
    isFake = false;
    logger.info('Account marked REAL: Followers and following both >= 20', { 
      followers: followersNum, 
      following: followingNum,
      hasDefaultAvatar: hasDefaultAvatar
    });
  }
  
  const accountVerdict = isFake ? 'FAKE' : 'REAL';

  const reasons = Object.values(breakdown)
    .flatMap((result) => result.evidence)
    .filter(Boolean);

  const prioritizedReasons = reasons.slice(0, 6);

  const recommendedAction =
    riskLevel === 'CRITICAL'
      ? 'Auto-lock account and escalate to fraud response'
      : riskLevel === 'HIGH'
        ? 'Throttle reach and queue for manual review'
        : riskLevel === 'MEDIUM'
          ? 'Introduce friction (captcha, 2FA challenge)'
          : 'Monitor silently';

  // Add fake reason to reasons list if account is fake due to zero stats
  const finalReasons = [...prioritizedReasons];
  if (isFake && fakeReason && !finalReasons.includes(fakeReason)) {
    finalReasons.unshift(fakeReason); // Add at the beginning
  }

  // Get posts count for display (not used in verdict logic)
  const contentFeatures = payload.contentFeatures || {};
  const posts = contentFeatures.posts || 0;

  return {
    riskScore,
    riskLevel,
    accountVerdict, // "REAL" or "FAKE"
    isFake, // boolean for easy checking
    fakeReason: isFake && fakeReason ? fakeReason : null, // Reason if fake due to zero stats
    stats: {
      followers,
      following,
      posts: posts, // For display only, not used in verdict
    },
    recommendedAction,
    breakdown,
    reasons: finalReasons.slice(0, 6), // Limit to 6 reasons
    metadata: {
      evaluatedAt: new Date().toISOString(),
      missingSignals: Object.keys(breakdown).filter((key) => !payload?.[signalKeyToPayloadField(key)]),
      signalWeights: SIGNAL_WEIGHTS,
      confidence: calculateConfidence(payload),
    },
  };
};

const signalKeyToPayloadField = (key) => {
  switch (key) {
    case 'profile':
      return 'profileMetadata';
    case 'content':
      return 'contentFeatures';
    case 'behavior':
      return 'behaviorPatterns';
    case 'network':
      return 'networkSignals';
    case 'multimedia':
      return 'multimediaSignals';
    case 'identity':
      return 'identitySignals';
    case 'device':
      return 'deviceMetadata';
    case 'reputation':
      return 'reportSignals';
    case 'threatIntel':
      return 'externalIntel';
    default:
      return undefined;
  }
};

const calculateConfidence = (payload = {}) => {
  // If data quality score is provided, use it (from screenshot analysis)
  if (payload.profileMetadata?._dataQualityScore !== undefined) {
    return Math.min(1.0, Math.max(0.3, payload.profileMetadata._dataQualityScore));
  }
  
  // Otherwise, calculate based on signal presence and data quality
  const populatedSignals = [
    'profileMetadata',
    'contentFeatures',
    'behaviorPatterns',
    'networkSignals',
    'multimediaSignals',
    'identitySignals',
    'deviceMetadata',
    'reportSignals',
    'externalIntel',
  ].filter((key) => Boolean(payload[key]));

  let baseConfidence = populatedSignals.length / 9;
  
  // Adjust confidence based on data quality indicators
  const profile = payload.profileMetadata || {};
  if (profile.username && profile.username !== 'unknown') {
    baseConfidence += 0.1; // Username detected
  }
  if (profile.accountAgeDays > 0) {
    baseConfidence += 0.1; // Account age detected
  }
  if (payload.networkSignals?.followers > 0 || payload.networkSignals?.following > 0) {
    baseConfidence += 0.1; // Network stats detected
  }
  
  return Number(Math.min(1.0, Math.max(0.3, baseConfidence)).toFixed(2));
};

export default {
  analyzeSocialAccount,
};





